package com.ocelot.codebase.sort.quicksort;

/**
 * 参考 Data Structures and Algorithm Analysis in Java --- Chapter 7.7 QuickSort
 *
 * 关注[仅简单列出]:
 *************************************************************
 * 1. 选择枢纽元
 *   目标 --> 接近选出N个数的中位数,使数组被平均分割.
 *   [x] 选择第一个元素作为枢纽元\选取前两互异元素关键字较大者:
 *       输入是预排序或反序时,将花费二次元时间,实际却没干任何事;
 *   [x] 随机选取枢纽元
 *       一种安全策略;
 *       但随机数生成开销较大,无法降低算法其余部分的平均运行时间;
 *   [v] 三数中值分割法(可以消除预排序输入的最坏情形):
 *       使用左端,右端和中心位置上德三个元素的中值作为枢纽元;
 *************************************************************
 * 2. 划分不相交集合(将小元素划分到数组的左边,将大元素划分到数组右边,小和大相对于枢纽元而言)
 *   以下是一种证明可行的分割策略
 *   1) 通过将枢纽元与最后的元素交换,使得枢纽元离开要被分割的数据段;
 *   2) 当i在j的左边时
 *      NOTE: 将i右移,移过那些小于枢纽元的元素; --- 停止时,i指向>=pivot的元素
 *      NOTE: 将j左移,移过那些大于枢纽元的元素; --- 停止时,j指向<=pivot的元素
 *      当i和j停止时,i指向一个大元素而j指向一个小元素;
 *   3-1) 如果i在j的左边,
 *        那么将两个元素互换(效果为将大元素推向右边而把小元素推向左边)
 *   3-2) 当i在j的右边(i和j交错后)
 *        将枢纽元与i所指向的元素交换
 *      <Q> 为什么枢纽元与i交换,而不是枢纽元与j交换
 *      <A> i指向小于等于枢纽元的元素,j指向大于等于枢纽元的元素
 *          当i与j交错时 --> ... j(<= pivot), i(>= pivot) ... pivot
 *          pivot与i交换 --> ... pivot, i(>= pivot) ... j(<= pivot) --> 不符合排序
 *          pivot与j交换 --> ... j(<= pivot), pivot ... i(>= pivot) --> 与排序要求相符
 *************************************************************
 * 3. 如何处理与枢纽元相等的元素
 *   <Q> 当i遇到一个等于枢纽元的元素,及j遇到一个等于枢纽元的元素两种情况下,是否应该停止
 *   <A> i和j的处理策略应该相同,否则可能会造成分割偏向一边
 *   [x]
 *   [v]
 *************************************************************
 *
 */
public class QuickSort {




}
