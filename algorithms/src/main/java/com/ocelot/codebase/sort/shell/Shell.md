# 希尔排序(缩减增量排序diminishing increment sort)
- 发明者: Donald Shell
> - 对于中等大小的数组,运行时间可以接受; 
> - 代码量很小, 不需要额外的内存空间;
> - 其他更加高效的排序算法, 除了对于很大的N, 可能只会比希尔排序快两倍(也许还达不到),而且更复杂;
> - 如果需要解决排序问题, 又没有系统排序函数可用, 那么可以选择希尔排序. 然后再考虑是否值得替换为复杂的排序算法.

- 相比于选择排序和插入排序, 希尔排序也可以用于大型数组.它对任意排序的数组表现也很好(??选择排序和插入排序的不适用情况) 
- 对于大规模乱序数组,插入排序很慢,因为它只交换相邻的元素,因此元素只能一点一点从数组的一端移到另一端;
> 希尔排序为了加快速度,简单的改进了插入排序,交换不相邻的元素以对数组的局部进行排序,最终用插入排序将局部有序的数组排序
- 希尔排序的思想: 使数组中任意间隔为h的元素都是有序的; 如果h很大,就可以将元素移到很远的地方,为实现更小的h有序创造方便.
- 通过比较相距一定间隔的元素;各趟比较所用的距离随着算法的进行而减小,直到只比较相邻元素的最后一趟排序为止.
- 使用增量hk的一趟排序之后,对于每一个i,都有a[i]≤a[i+h<sub>k</sub>];所有相隔hk的元素都被排序;且这种排序性在后续的排序中被保持;
- 希尔排序高效的一个原因: 权衡了子数组的规模和有序性.排序之初,每个子数组都很短,排序之后子数组都是部分有序的,这两种情况都很适合插入排序.
> 子数组部分有序的程度,取决于递增序列的选择

## 关注点
### 增量序列
> 算法的性能不仅取决于h,还取决于h之间的数学性质,不如其公因子.
> 因此, 有些增量序列比另外一些增量序列更好.

希尔排序使用一个序列h<sub>1</sub>, h<sub>2</sub>,..., h<sub>t</sub>,只要h<sub>1</sub> = 1,任何增量序列都是可行的.

#### [x] Shell增量 (流行但是不好的) 
- h<sub>t</sub>=⎣N/2⎦ 和 h<sub>k</sub>=⎣h<sub>k+1</sub>/2⎦
- 最坏情形: O(N<sup>2</sup>)

#### [o] Hibbard增量 (Data structures and Algorithm Analysis in Java 定理7.4)
- 1, 3, ..., 2<sup>k</sup>-1
- 最坏情形: O(N<sup>3/2</sup>)

#### [v] Sedgewick增量1 Algorithms Forth Edition Robert Sedgewick
- 实现简单,基本够用`while(h < N/3) h = 3 * h + 1`
- 1, 4, 13, ... , 3*h+1
- 最坏情形: O(N<sup>4/3</sup>) 

## 运行时间分析
希尔排序的运行时间,依赖于增量序列的选择
> 使用希尔增量(shell sort)时,希尔排序的最坏情形运行时间为O(N<sup>2</sup>)
- 取N是2的幂(除最后一个增量是1外,所有的增量都是偶数);
- 输入数组,偶数位置有N/2个同为最大的数,奇数位置有N/2个同为最小的数
由于除最后一个增量外,所有的增量都是偶数,
因此当进行最后一趟排序前,
N/2个最大的元素仍然在偶数位置上,
而N/2个最小的元素也还在奇数位置上;
于是,在最后一趟排序开始之前第i个最小的数(i≤N/2)在位置2i-1上;
将第i个元素恢复到正确的卫视需要再数组中移动i-1个间隔;
这样,仅仅将N/2个最小的元素方法到正确的位置上,就需要至少∑<sub>i=1</sub><sup>N/2</sup>i-1=O(N<sup>2</sup>)
 